//! # `void`åŠŸèƒ½
//! * ğŸ¯ä»¥JSçš„`void XXX`è¯­æ³•ï¼Œå®ç°ã€Œå–æ¶ˆå‡½æ•°è¾“å‡ºã€åŠŸèƒ½

/// ä½œä¸ºç‰¹å¾çš„[`Void`]
/// * ğŸš©åªå«æœ‰ä¸€ä¸ª[`void`](`Void::void`)æ–¹æ³•ï¼Œç›´æ¥é€šè¿‡`self.void()`è¯­æ³•è°ƒç”¨
/// * ğŸ¯åç¼€å¯¹æ ‡JavaScript`void XXX`è¯­æ³•
///
/// ## ç”¨ä¾‹
///
/// ```rust
/// use nar_dev_utils::Void;
/// fn one() -> i32 {
///     1
/// }
///
/// match 1 {
///     1 => one().void(),
///     _ => (),
/// }
/// ```
pub trait Void: Sized {
    #[inline(always)]
    fn void(self) {}
}
impl<T: Sized> Void for T {}

/// ä½œä¸ºå‡½æ•°çš„`void`æ–¹æ³•
/// * ğŸš©ç›´æ¥å†…è”Rustè‡ªå¸¦çš„[`drop`]
/// * ğŸ“å¯¹äºä½œä¸ºå‡½æ•°çš„`void`ï¼Œå»ºè®®ä½¿ç”¨Rustè‡ªå¸¦çš„`drop`
#[inline(always)]
pub fn void<T>(t: T) {
    drop(t)
}

/// # `void`å®
/// * ğŸ¯ç®€å•åœ°åœ¨ã€Œæ— éœ€ä½¿ç”¨è¿”å›å€¼ã€çš„æƒ…å†µä¸­ã€å–æ¶ˆè¿”å›å€¼ã€‘
///   * ğŸ“„åœ¨`match`è¯­å¥ä¸­è§£å†³ã€Œè¿”å›å€¼ä¸ä¸€è‡´ã€çš„é—®é¢˜
/// * âœ…ä¸JavaScriptä¸­`void f(x)`ç­‰åŒ
/// * âœ¨å¯åœ¨å…¶ä¸­åŠ å…¥ä»»æ„å¯æ‰§è¡Œä»£ç ï¼Œè€Œä¸ä»…ä»…æ˜¯å•ä¸ªè¡¨è¾¾å¼
/// * ğŸš©é€šè¿‡ã€Œå—è¡¨è¾¾å¼+æœ«å°¾åˆ†å·ã€å®ç°
///
/// ## ç”¨ä¾‹
///
/// ```rust
/// use nar_dev_utils::void;
/// fn one() -> i32 {
///     println!("one!");
///     1
/// }
/// assert_eq!(one(), 1);
/// match 2 {
///     1 => void!(one()),
///     _ => println!("other!"),
/// }
/// match 1 {
///     0 => void!({ dbg!("0") }),
///     1 => void![println!("1"); one()],
///     _ => println!("other!"),
/// }
/// ```
#[macro_export]
macro_rules! void {
    ($($code:tt)*) => {{
        $($code)*;
    }};
}
